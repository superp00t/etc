package idl

import (
	"fmt"
	"strings"
)

func (s *Syntax) GoImports() []string {
	var big bool

	for _, v := range s.MessageTypes {
		for _, y := range v.StructTypes {
			if y.Type == Mbigint {
				big = true
			}
		}
	}

	var i []string
	if big {
		i = append(i, "math/big")
	}

	if len(s.RPC) != 0 {
		i = append(i, []string{
			"io",
			"net/http",
			"github.com/gorilla/mux",
		}...)
	}
	return i
}

func (s *Syntax) GenerateGo() (string, string) {
	imports := []string{
		"encoding/json",
		"github.com/superp00t/etc",
	}

	imports = append(imports, s.GoImports()...)

	var rpcUserFile string
	if len(s.RPC) != 0 {
		rpcUserFile = "package " + s.PackageName + "\n\n"
	}

	src := "// Code generated by \"etc-schema-gen\"; DO NOT EDIT\n\n"
	src += fmt.Sprintf("package %s\n\nimport (\n", s.PackageName)
	for _, v := range imports {
		src += "\t\"" + v + "\"\n"
	}
	src += ")\n"

	if len(s.Enums) > 0 {
		pkg := s.SortedEnumTypes()
		for _, v := range pkg {
			src += "\ntype " + v + " uint64\n"
		}
	}

	src += "const ("
	if len(s.Enums) > 0 {
		pkg := s.SortedEnumTypes()
		for _, v := range pkg {
			en := s.Enums[v]
			for idx, e := range en.keys {
				src += fmt.Sprintf("\n\t%s %s = %d\n", e, v, en.vals[idx])
			}
		}
		src += "\n"
	}
	src += "\n)"

	encS := ""
	encodeS := ""
	jsun := ""
	for k, v := range s.MessageTypes {
		sname := goNormalizeExportField(k)
		// generate decoder
		jsun += fmt.Sprintf("func (v *%s) String() string {\n\tb, _ := json.Marshal(v)\n\treturn string(b)\n}", sname)
		encodeS += "func (v *" + sname + ") Marshal() []byte {\n\tif v == nil { return nil }\n\td := etc.NewBuffer()\n"
		encS += "func Unmarshal" + sname + "(data []byte) (*" + sname + ", error) {\n"
		if s.Pragmas["zlib-compress"] == true {
			encS += "\tvar err error\n\tinput, err := etc.ZlibDecompress(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t"
		} else {
			encS += "\tvar err error\n\tinput := data\n"
		}

		encS += "\tv := new(" + sname + ")\n\td := etc.MkBuffer(input)\n"

		src += fmt.Sprintf("type %s struct {\n", sname)
		for _, field := range v.StructTypes {
			fname := goNormalizeExportField(field.FieldName)
			ap := ""
			if field.ArrayType {
				ap = "[]"
			}
			src += fmt.Sprintf("\t%s\t%s%s", fname, ap, goType(field))
			src += "\t" + "`" + "json:\"" + field.FieldName + "\"`\n"

			encName := "v." + fname
			if field.ArrayType {
				encodeS += "\td.WriteUint(uint64(len(v." + fname + ")))\n"
				encodeS += "\tfor _i := 0; _i < len(v." + fname + "); _i++ {\n\t\te := v." + fname + "[_i]\n\t"
				encName = "e"

				l := "ln_" + fname
				encS += "\t" + l + " := int(d.ReadUint())\n\tfor _i := 0; _i < " + l + "; _i++ {\n\t"
			}

			if field.Type == Mstruct {
				encodeS += "\td.WriteLimitedBytes(" + encName + ".Marshal())\n"
				encS += "\tdcc, err := etc.ZlibDecompress(d.ReadLimitedBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t"
				encS += "\tchnk, err := Unmarshal" + field.StructName + "(dcc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n"
				if field.ArrayType {
					encS += "\t\tv." + fname + " = append(v." + fname + ", chnk)\n"
				} else {
					encS += "\tv." + fname + " = chnk\n"
				}
			} else {
				argName := "v." + fname
				if field.ArrayType {
					argName = "e"
					encS += "\tv." + fname + " = append(v." + fname + ", " + goReadFunc(field) + ")\n"
				} else {
					encS += "\tv." + fname + " = " + goReadFunc(field) + "\n"
				}
				encodeS += "\t" + goWriteFunc(field, argName) + "\n"
			}

			if field.ArrayType {
				encodeS += "\t}\n"
				encS += "\t}\n"
			}
		}

		returnArg := "return d.Bytes()"
		if s.Pragmas["zlib-compress"] == true {
			returnArg = "return etc.ZlibCompress(d.Bytes())"
		}

		encodeS += "\t" + returnArg + "\n}\n\n"
		encS += "\treturn v, err\n}\n\n"
		src += fmt.Sprintf("}\n\n")
	}

	rpcs := ""
	for k, v := range s.RPC {
		rpcs += "\n\nfunc New" + goNormalizeExportField(k) + "Service() http.Handler {\n\t"
		rpcs += "r := mux.NewRouter()\n\t"
		rpcs += "r.HandleFunc(\"/rpc/{call}\", Handle" + goNormalizeExportField(k) + ")\n\treturn r\n}\n\n"

		rpcs += "func Handle" + goNormalizeExportField(k) + "(rw http.ResponseWriter, r *http.Request) {\n\t"
		rpcs += "buff := etc.NewBuffer()\n\tio.Copy(buff, r.Body)\n\t"
		rpcs += "switch mux.Vars(r)[\"call\"] {\n\t"
		for _, y := range v.Procs {
			normnm := goNormalizeExportField(y.Name)
			rpcs += fmt.Sprintf("case \"%s.%s\":\n\t\t", k, y.Name)
			if y.RequestType != "void" {
				rpcs += fmt.Sprintf("msg, err := Unmarshal%s(buff.Bytes())\n\t\tif err != nil {\n\t\t\thttp.Error(rw, err.Error(), 400)\n\t\t}\n\t", goNormalizeExportField(y.RequestType))
			}

			if y.ResponseType == "void" && y.RequestType == "void" {
				rpcs += fmt.Sprintf("Handle%s()\n\t", normnm)
				rpcUserFile += fmt.Sprintf("\nfunc Handle%s() {}\n", normnm)
			}

			if y.ResponseType == "void" && y.RequestType != "void" {
				rpcs += fmt.Sprintf("Handle%s(msg)\n\t", normnm)
				rpcUserFile += fmt.Sprintf("\nfunc Handle%s(msg *%s) {}\n", normnm, goNormalizeExportField(y.RequestType))
			}

			if y.ResponseType != "void" && y.RequestType == "void" {
				rpcs += fmt.Sprintf("rw.Write(Handle%s().Marshal())\n\t", normnm)
				rpcUserFile += fmt.Sprintf("\nfunc Handle%s() (*%s) {\n\treturn nil\n}\n", normnm, goNormalizeExportField(y.ResponseType))
			}

			if y.ResponseType != "void" && y.RequestType != "void" {
				rpcs += fmt.Sprintf("rw.Write(Handle%s(msg).Marshal())\n\t", normnm)
				rpcUserFile += fmt.Sprintf("\nfunc Handle%s(msg *%s) (*%s) {\n\treturn nil\n}\n", normnm, goNormalizeExportField(y.RequestType), goNormalizeExportField(y.ResponseType))
			}
		}
		rpcs += "}\n}"
	}

	return src + encS + encodeS + jsun + rpcs, rpcUserFile
}

func goType(m *SpecType) string {
	switch m.Type {
	case Mbytes:
		return "[]byte"
	case Mstring:
		return "string"
	case Muint16:
		return "uint16"
	case Muint32:
		return "uint32"
	case Muint64:
		return "uint64"
	case Muint8:
		return "uint8"
	case Muuid:
		return "etc.UUID"
	case Mbigint:
		return "*big.Int"
	case Mfloat32:
		return "float32"
	case Mfloat64:
		return "float64"
	case Muint:
		return "uint64"
	case Mint:
		return "int64"
	case Mbool:
		return "bool"
	case Mstruct:
		return "*" + m.StructName
	default:
		return "interface{}"
	}
}

func goWriteFunc(m *SpecType, fname string) string {
	switch m.Type {
	case Mdate:
		return fmt.Sprintf("d.WriteDate(%s)", fname)
	case Mbytes:
		return fmt.Sprintf("d.WriteLimitedBytes(%s)", fname)
	case Mstring:
		return fmt.Sprintf("d.WriteUTF8(%s)", fname)
	case Muint16:
		return fmt.Sprintf("d.WriteUint16(%s)", fname)
	case Muint32:
		return fmt.Sprintf("d.WriteUint32(%s)", fname)
	case Muint64:
		return fmt.Sprintf("d.WriteUint64(%s)", fname)
	case Muint8:
		return fmt.Sprintf("d.WriteByte(%s)", fname)
	case Mbool:
		return fmt.Sprintf("d.WriteBool(%s)", fname)
	case Muuid:
		return fmt.Sprintf("d.WriteUUID(%s)", fname)
	case Mfloat32:
		return fmt.Sprintf("d.WriteFloat32(%s)", fname)
	case Mfloat64:
		return fmt.Sprintf("d.WriteFloat64(%s)", fname)
	case Mint:
		return fmt.Sprintf("d.WriteInt(%s)", fname)
	case Muint:
		return fmt.Sprintf("d.WriteUint(%s)", fname)
	case Mbigint:
		return fmt.Sprintf("d.WriteBigInt(%s)", fname)
	case Mstruct:
		return "/* NOT YET IMPLEMENTED */"
	default:
		return "interface{}"
	}
}

func goReadFunc(m *SpecType) string {
	switch m.Type {
	case Mdate:
		return "d.ReadDate()"
	case Mbytes:
		return "d.ReadLimitedBytes()"
	case Mstring:
		return "d.ReadUTF8()"
	case Muint16:
		return "d.ReadUint16()"
	case Muint32:
		return "d.ReadUint32()"
	case Muint64:
		return "d.ReadUint64()"
	case Mbool:
		return "d.ReadBool()"
	case Muint8:
		return "d.ReadByte()"
	case Mfloat32:
		return "d.ReadFloat32()"
	case Mfloat64:
		return "d.ReadFloat64()"
	case Mint:
		return "d.ReadInt()"
	case Muint:
		return "d.ReadUint()"
	case Mbigint:
		return "d.ReadBigInt()"
	case Muuid:
		return "d.ReadUUID()"
	case Mstruct:
		return "/* NOT YET IMPLEMENTED */"
	default:
		return "interface{}"
	}
}

func goNormalizeExportField(input string) string {
	in := []rune(input)
	tail := input[1:]
	firstChar := string(in[0])
	firstChar = strings.ToUpper(firstChar)

	return firstChar + string(tail)
}
